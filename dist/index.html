<!doctype html>

<html lang=en>

<head>
  <meta charset=utf-8>
  <title>Fette Palette</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
  <style>
    :root {
      font-family: "Inter", sans-serif;
      background: #202124;
      --sidebarwidth: 20rem;
    }
    .settings {
      position: fixed;
      width: var(--sidebarwidth);
      padding: 4.6rem 2rem;
      background: #202124;
      color: #fff;
      order: 1;
      right: 0;
      top: 0;
      bottom: 0;
      overflow-y: auto;
      box-sizing: border-box;
      z-index: 2;
    }
    .settings h3 {
      margin-bottom: 2em;
    }
    .main {
      margin-right: var(--sidebarwidth);
      background: #fff;
      padding: 2rem;
    }
    .main aside {
      max-width: 27rem;
    }

    h1 {
      font-size: calc(1rem + 11vw);
      font-weight: 900;
      letter-spacing: -0.055em;
      margin-top: 2rem;
      line-height: .85;
    }
    pre {
      font-family: monospace;
      font-size: .8rem;
      max-width: 100%;
    }

    h2 {
      margin: 1.5em 0 1rem;
      font-size: calc(1rem + 2vw);
      line-height: 1.1;
      font-weight: 800;
      letter-spacing: -0.04em;
      line-height: 0.72;
      margin-bottom: 1em;
    }
    h2 + p {
      margin-bottom: 1rem;
    }
    a {
      font-size: 1em;
      margin-top: .4em;
      font-weight: 700;
    }
    [data-colors] {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
    }
    [data-colors] i {
      flex: 1 0 calc(var(--w, 0.11) * 100%);
      width: calc(var(--w, 0.11) * 100%);
      padding-top: calc(var(--w, 0.11) * 100%);
      background: hsl(var(--h), calc(var(--s) * 1%), calc(var(--l) * 1%));
    }
    
    [data-palette] {
      display: flex;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    [data-palette-xl] {
      display: flex;
      flex-wrap: wrap;
    }

    [data-palette] .palette-sample {
      outline: 4px solid #fff;
    }

    .palette-sample {
      position: relative;
      background: var(--col-0);
      padding-top: calc(100% / var(--x));
      margin: 0;
      user-select: none;
      flex: 0 0 calc(100% / var(--x));
    }
    .palette-sample b {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50%;
      height: 50%;
      transform: translate(-50%, -50%);
      background: var(--col-1);
    }
    .palette-sample i {
      position: absolute;
      width: 50%;
      height: 50%;
      right: 0;
    }
    .palette-sample i:first-child {
      background: var(--col-2);
    }
    .palette-sample i:last-child {
      bottom: 0;
      background: var(--col-3);
    }

    figure {
      margin: 0;
      padding: 0;
    }
    [data-figure] {
      background-image: linear-gradient(to top, black, rgba(0, 0, 0, 0)), linear-gradient(to left, hsl(var(--deg, 0deg), 100%, 50%), hsl(var(--deg, 0deg), 0%, 100%));
    }
    [data-ramp] {
      margin-top: 1rem;
      height: 4rem;
    }
    [data-list] {
      margin: 2rem 0;
      display: flex;
      gap: 0.5rem;
    }
    [data-list] .contrast div {
      margin-top: .35em;
    }
    [data-list] h3 {
      margin-bottom: 0.5rem;
      margin-top: 2rem;
      display: none;
    }
    [data-list] h5 {
      font-weight: 600;
      margin-top: .75em;
      margin-bottom: .4em;
    }
    [data-list] li {
      font-size: 0.8rem;
      line-height: 1.2;
      position: relative;
      padding-bottom: .5em;
    }
    [data-list] li ~ li {
      margin-top: .5rem;
    }
    [data-list] li::before {
      user-select: none;
      content: "";
      background: var(--col);
      display: block;
      width: 100%;
      height: 2rem;
      margin-bottom: 0.25rem;
    }
    [data-copy] {
      margin-top: .15em;
    }
    [data-list] .color-info {
      top: 100%;
      z-index: 1;
      left: 0;
      right: 0;
      padding: .25rem 0 .5rem;
      transition: 200ms height;
    }
    .color-info > div {
      margin-top: .5em;
    }
    [data-list] > div {
      flex: 1;
    }
    [data-copy] {
      cursor: pointer;
    }
    p {
      margin-top: 1em;
      max-width: 20rem;
      font-size: 0.8em;
      letter-spacing: 0.002em;
      line-height: 1.38;
      font-weight: 400;
    }

    .pane__section,
    .pane__label {
      display: block;
    }

    .pane__label {
      font-size: .8rem;
      font-weight: 400;
      line-height: 1;
      margin-bottom: .8em;
    }

    .pane {
      box-sizing: border-box;
      background: var(--color-bg);
      display: block;
      cursor: default;
      background: #202124;
      color: #fff;
      --size-gutter: 1rem;
      --color-inverted: #fff;
    }
    .pane__section {
      display: block;
    }
    .pane__section + .pane__section {
      margin-top: calc(var(--size-gutter) * 2);
    }
    .pane__inputs {
      display: flex;
      touch-action: manipulation;
    }
    .pane__input--number {
      flex-grow: 1;
    }
    .pane .pane__input--number + input[type=number] {
      display: block;
      flex-basis: 4rem;
      width: 4rem;
    }
    .pane__desc {
      margin: 1em 0 3em;
      font-size: 0.6em;
    }
    .pane select {
      font-size: 0.8em;
      border-radius: 2rem;
      padding: 0.2rem;
    }
    .pane input, 
    .pane select {
      display: block;
      box-sizing: border-box;
      touch-action: manipulation;
      font-family: 'Space Mono', monospace;
      border: none;
      width: auto;
    }
    .pane input[type=number], 
    .pane select[type=number] {
      color: var(--color-inverted);
      background: none;
      border: none;
      text-align: right;
      font-size: 0.8em;
      flex: 0 0 3rem;
      width: 3rem;
    }
    .pane input {
      background-color: transparent;
    }
    .pane input[type=range] {
      -webkit-appearance: none;
    }
    .pane input[type=range] {
      margin: 0;
      padding-top: 0.7em;
      margin-top: -0.7em;
    }
    .pane input[type=range]:focus {
      outline: none;
    }
    .pane input[type=range]:focus::-webkit-slider-thumb {
      background-color: var(--color-inverted);
      clip-path: polygon(100% 0%, 0% 0%, 50% 100%, 50% 100%);
    }
    .pane input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 1rem;
      background: transparent;
      color: var(--c-black);
      border-radius: 0;
      border: solid var(--color-inverted);
      border-width: 0 0 1px;
    }
    .pane input[type=range]::-webkit-slider-thumb {
      border: 2px solid transparent;
      height: 0.75rem;
      width: 0.5rem;
      border-radius: 0;
      background: var(--color-inverted);
      -webkit-appearance: none;
      margin-top: 0.25rem;
      transition: 150ms background-color, 200ms clip-path, 200ms -webkit-clip-path;
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
    }
    .pane input[type=range]::-moz-range-track {
      width: 100%;
      height: 1rem;
      background: transparent;
      color: var(--c-black);
      border-radius: 0;
      border: solid var(--color-inverted);
      border-width: 0 0 1px;
    }
    .pane input[type=range]::-moz-range-thumb {
      border: 2px solid transparent;
      height: 0.75rem;
      width: 0.5rem;
      border-radius: 0;
      background: var(--color-inverted);
      -webkit-appearance: none;
      margin-top: 0.25rem;
      transition: 150ms background-color, 200ms clip-path, 200ms -webkit-clip-path;
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
    }
    .pane input[type=range]::-ms-track {
      width: 100%;
      height: 1rem;
      background: transparent;
      color: var(--c-black);
      border-radius: 0;
      border: solid var(--color-inverted);
      border-width: 0 0 1px;
    }
    .pane input[type=range]::-ms-fill-lower {
      background: var(--color-inverted);
      border: none;
      border-radius: 100%;
    }
    .pane input[type=range]::-ms-fill-upper {
      background: var(--color-inverted);
      border-radius: 100%;
      box-shadow: none;
    }
    .pane input[type=range]::-ms-thumb {
      border: 2px solid transparent;
      height: 0.75rem;
      width: 0.5rem;
      border-radius: 0;
      background: var(--color-inverted);
      -webkit-appearance: none;
      margin-top: 0.25rem;
      transition: 150ms background-color, 200ms clip-path, 200ms -webkit-clip-path;
      clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
    }
    .pane select {
      color: var(--color-inverted);
      width: 100%;
      box-sizing: border-box;
      -webkit-appearance: none;
      border: 0;
      box-shadow: 0 1px 0 0 var(--color-inverted);
      border-radius: 0;
      padding: 0.25rem 1rem 0.25rem 0rem;
      background-color: transparent;
      background-size: 1.25em 1.25em;
      background-image: conic-gradient(var(--color-inverted) 5%, transparent 0 95%, var(--color-inverted) 0);
      background-repeat: no-repeat;
      background-position: right 0% top 120%;
    }
    .pane select option {
      color: var(--color-bg);
    }
    .pane select:focus {
      outline: none;
      background-color: transparent;
    }
    .settings .code-title {
      margin-top: 3rem;
      margin-bottom: 1rem;
    }

    svg:not(:root){
      overflow: visible;
    } 
    
  </style>
</head>

<body>
  <article class="app">
    <aside class="settings">
      <!--h3>Settings</h3-->
      
      <div class="settings__inner">
        <div data-pane></div>
        <h3 class="code-title">Function Call</h3>
        <code>
          <pre data-code></pre>
        </code>
      </div>
    </aside>
    <section class="main">
      <h1>Fette&shy;Palette</h1>
      <p>Color palette generation using curves within the HSV color model</p>
      <!--p>
        <mark>FetteÂ­Palette</mark> is a function that returns an object containing
        as many base colors, tints and shades as set in <code>colors</code>.
      </p-->
      <aside>
        <h2>HSL Slice Preview</h2>
        <figure><svg data-figure viewbox="0 0 100 100"></svg></figure>
      </aside>
      <aside>
        <h2>Full Palette</h2>
        <div data-colors></div>
      </aside>
    
      <aside>
        <h2>Example Use</h2>
        <p><strong>4 random colors form palette</strong> (click & hold to re-generate)</p>
        <div data-palette-xl>
        </div>

        <div data-palette>
        </div>
        <div data-ramp></div>
      </aside>

      <aside>
        <h2>Full Palette</h2>
        <div data-list></div>
      </aside>

      <aside>
        <h2>Color Names</h2>
        <div data-names></div>
      </aside>
      <p>fork on <a href="https://github.com/meodai/fettepalette">github</a> made by <a href="https://www.elastiq.ch/">elastiq</a>.</p>
    </section>
  </article>
  <script src="https://cdn.jsdelivr.net/npm/culori@0.18.2/build/culori.umd.js"></script>

  <script type="module">
    import generateRandomColorRamp ,{ hsv2hsl, random, pointOnCurve } from './index.js';

    console.clear();
    
    const shuffleArray = array => {
      let arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    class Pane {
      constructor (
        $dom, 
        nameSpace = 'pane',
        throttleTimer = 50,
      ) {
        this.watches = new Map();
        this.nameSpace = nameSpace;
        
        this.$dom = $dom;
        this.$el = document.createElement('div');
        this.$el.classList.add(nameSpace);
        this.$el.addEventListener('input', (e) => this._onChange(e), {
          captures: true,
          passive: true,
        }, true);

        $dom.appendChild(this.$el);

        this.events = {};
        this.timer;
      }

      _onChange (event) {
        const $target = event.target;
        
        if ('key' in $target.dataset) {
          const key = $target.dataset.key;
          const ref = this.watches.get(key);
          
          if ( $target.dataset.type === 'number') {
            ref[key] = new Number($target.value);
          } else {
            ref[key] = $target.value;
          }

          if('siblingid' in $target.dataset) {
            document.getElementById($target.dataset.siblingid).value = $target.value;
          }

          if (this.events.hasOwnProperty('change')) {
            clearTimeout(this.timer); 
            this.events['change'].forEach(fn => {
              this.timer = setTimeout(() => {
                fn.apply(ref);
              }, this.throttleTimer);
            });
          }
        }   
      }

      on(event, fn) {
        if (!this.events.hasOwnProperty(event)) {
          this.events[event] = [];
        }
        this.events[event].push(fn);
      }

      addInput(reference, key, options) {
        this.watches.set(key, reference);
        this._appendInput(reference, key, options)
      }

      _appendInput(reference, key, options) {
        let type = typeof reference[key];

        const $e = document.createElement('label');
        const $label = document.createElement('strong');
        const $section = document.createElement('div');

        let $i, $in;

        if (type === 'number') {
          $i = document.createElement('input');
          $in = document.createElement('input');

          $i.setAttribute('type', 'range');
          $in.setAttribute('type', 'number');

          if (options.hasOwnProperty('min')) {
            $i.setAttribute('min', options.min);
            $in.setAttribute('min', options.min);
          }
          if (options.hasOwnProperty('max')) {
            $i.setAttribute('max', options.max);
            $in.setAttribute('max', options.max);
          }
          if (options.hasOwnProperty('step')) {
            $i.setAttribute('step', options.step);
            $in.setAttribute('step', options.step);
          }
        } else if (type === 'string') {
          if (options.hasOwnProperty('options')) {
            $i = document.createElement('select');

            options.options.forEach(option => {
              const $opt = document.createElement('option');
              $opt.setAttribute('value', option);
              $opt.innerHTML = option;
              $i.appendChild($opt);
            });
          } else {
            $i = document.createElement('input');
            $i.setAttribute('type', 'text');
          }
        }

        $i.dataset.key = key;
        $i.dataset.type = type;
        $i.value = reference[key];
        $i.id = `${this.nameSpace}--${key}`;
        $i.classList.add(
          `${this.nameSpace}__input`,
          `${this.nameSpace}__input--${type}`
        );
        
        $section.appendChild($i);
        $section.classList.add(
          `${this.nameSpace}__inputs`,
          `${this.nameSpace}__inputs--${type}`
        );

        if ($in) {
          $in.dataset.key = key;
          $in.dataset.type = type;
          $in.value = reference[key];
          $in.id = `${this.nameSpace}--${key}--value`;
          $i.classList.add(
            `${this.nameSpace}__input`,
            `${this.nameSpace}__input--${type}`
          );
          $in.dataset.siblingid = `${this.nameSpace}--${key}`;
          $i.dataset.siblingid = `${this.nameSpace}--${key}--value`;
          $section.appendChild($in);
        }

        $label.innerHTML = key;
        $label.classList.add(`${this.nameSpace}__label`);
        
        $e.classList.add(`${this.nameSpace}__section`);
        $e.appendChild($label);
        $e.append($section);

        this.$el.appendChild($e);
      }
    }

    const pane = new Pane(document.querySelector('[data-pane]'))

    const PARAMS = {
      colors: 9,
      centerHue: 0,
      hueCycle: 0.3,
      offsetTint: 0.01,
      offsetShade: 0.01,
      curveAccent: 0,
      tintShadeHueShift: 0.01,
      colorMode: 'hsl',
      curveMethod: 'lamÃ©', //arc, pow
      offsetCurveModTint: 0.03,
      offsetCurveModShade: 0.03,
      minSaturation: 0,
      minLight: 0,
      maxSaturation: 1,
      maxLight: 1,
    };

    pane.addInput(
      PARAMS, 'colors',
      { min: 3, max: 35, step: 1 }
    );
    pane.addInput(
      PARAMS, 'centerHue',
      { min: 0, max: 360, step: 0.1 }
    );

    pane.addInput(
      PARAMS, 'hueCycle',
      { min: 0, max: 1.5, step: 0.001 }
    );
    pane.addInput(PARAMS, 'curveMethod', {
      options: [
        'lamÃ©',
        'arc',
        'pow',
        'powY',
        'powX',
      ],
    });
    pane.addInput(
      PARAMS, 'curveAccent',
      { min: -0.095, max: 1, step: 0.001 }
    );
    pane.addInput(
      PARAMS, 'offsetTint',
      { min: 0, max: 0.4, step: 0.001 }
    );
    pane.addInput(
      PARAMS, 'offsetShade',
      { min: 0, max: 0.4, step: 0.001 }
    );
    pane.addInput(
      PARAMS, 'offsetCurveModTint',
      { min: 0, max: 0.4, step: 0.0001 }
    );
    pane.addInput(
      PARAMS, 'offsetCurveModShade',
      { min: 0, max: 0.4, step: 0.0001 }
    );
    pane.addInput(
      PARAMS, 'tintShadeHueShift',
      { min: 0, max: 1, step: 0.001 }
    );
    pane.addInput(
      PARAMS, 'minSaturation',
      { min: 0, max: 1, step: 0.001 }
    );
    pane.addInput( 
      PARAMS, 'minLight',
      { min: 0, max: 1, step: 0.001 }
    );
    pane.addInput(
      PARAMS, 'maxSaturation',
      { min: 0, max: 1, step: 0.001 }
    );
    pane.addInput(
      PARAMS, 'maxLight',
      { min: 0, max: 1, step: 0.001 }
    );

    const $pal = document.querySelector('[data-palette]');
    const $palxl = document.querySelector('[data-palette-xl]');
    const $picker = document.querySelector('[data-figure]');
    const $ramp = document.querySelector('[data-ramp]');
    let colors = [];

    const palette = (colors, method) => {
      let allColors = [];

      const lightColors = shuffleArray(colors.light);
      const mediumColors = shuffleArray(colors.base);
      const darkColors = shuffleArray(colors.dark);

      switch (method) {
        case 'random':
          allColors = shuffleArray(colors.all);
          break;
        case 'l2md':
          allColors = [lightColors[0], mediumColors[0], darkColors[0], lightColors[1]];
          break;
        case 'lmd2':
          allColors = [darkColors[0], mediumColors[0], lightColors[0], darkColors[1]];
          break;
        case 'lm2d':
          allColors = [mediumColors[1], mediumColors[0], lightColors[0], darkColors[1]];
          break;
      }

      let localcolors = [...allColors];
      $pal.innerHTML = '';

      $palxl.innerHTML = '';
      
      for (let i = 0; i < 4 * 4; i++) {
        $pal.appendChild(paletteDom(localcolors, 4));
        localcolors = shuffleArray(localcolors);
      }

      $palxl.appendChild(paletteDom(localcolors, 1));
      
      $ramp.style.setProperty('background', `linear-gradient(90deg, ${allColors.slice(0, 4).sort((a, b) => b.hsl[2] - a.hsl[2]).map(c => `hsl(${c.hsl[0]},${c.hsl[1] * 100}%,${c.hsl[2] * 100}%)`).join(',')})`)
    }

    function paletteDom (colorArr, x=1) {
      const $div = document.createElement('div');
      $div.classList.add('palette-sample');
      $div.style.setProperty('--x', x);
      $div.innerHTML = '<b><i></i><i></i></b>';

      for (let i = 0; i < 4; i++) {
        $div.style.setProperty(`--col-${i}`, `hsl(${colorArr[i].hsl[0]},${colorArr[i].hsl[1] * 100}%,${colorArr[i].hsl[2] * 100}%)`);
      }

      return $div;
    }

    function bam() {
      colors = generateRandomColorRamp({
        total: PARAMS.colors,
        centerHue: PARAMS.centerHue,
        hueCycle: PARAMS.hueCycle,
        offsetTint: PARAMS.offsetTint,
        offsetShade: PARAMS.offsetShade,
        curveAccent: PARAMS.curveAccent,
        tintShadeHueShift: PARAMS.tintShadeHueShift,
        curveMethod: PARAMS.curveMethod,
        offsetCurveModTint: PARAMS.offsetCurveModTint,
        offsetCurveModShade: PARAMS.offsetCurveModShade,
        minSaturationLight: [PARAMS.minSaturation, PARAMS.minLight],
        maxSaturationLight: [PARAMS.maxSaturation, PARAMS.maxLight],
      });

      // Mutate colors object
      for (const key in colors) {
        colors[key] = colors[key].map(([h, s, l]) => {
          const { r, g, b } = culori.converter('rgb')({ mode: 'hsl', h: 0, s: 1, l: .5 })
          return {
            hsl: [h, s, l],
            rgb: [r * 255, g * 255, b * 255],
            hex: culori.formatHex({ mode: 'hsl', h, s, l }),
            contrast: {
              white: culori.wcagContrast('#ffffff', { mode: 'hsl', h, s, l }),
              black: culori.wcagContrast('#000000', { mode: 'hsl', h, s, l })
            }
          }
        });
      }

      console.clear();

      document.querySelector('[data-code]').innerHTML = `
generateRandomColorRamp({
  total: ${PARAMS.colors},
  centerHue: ${PARAMS.centerHue},
  hueCycle: ${PARAMS.hueCycle},
  curveMethod: '${PARAMS.curveMethod}',
  curveAccent: ${PARAMS.curveAccent},
  offsetTint: ${PARAMS.offsetTint},
  offsetShade: ${PARAMS.offsetShade},
  tintShadeHueShift: ${PARAMS.tintShadeHueShift},
  offsetCurveModTint: ${PARAMS.offsetCurveModTint},
  offsetCurveModShade: ${PARAMS.offsetCurveModShade},
  minSaturationLight: [${PARAMS.minSaturation}, ${PARAMS.minLight}],
  maxSaturationLight: [${PARAMS.maxSaturation}, ${PARAMS.maxLight}],
});
`
      points(
        PARAMS.colors,
        PARAMS.offsetTint,
        PARAMS.offsetShade,
        PARAMS.curveAccent,
        colors.base,
        PARAMS.curveMethod,
        PARAMS.offsetCurveModTint,
        PARAMS.offsetCurveModShade,
        [PARAMS.minSaturation, PARAMS.minLight],
        [PARAMS.maxSaturation, PARAMS.maxLight]
      );

      $picker.style.setProperty(`--deg`, `${colors.all[Math.floor(colors.all.length * .5)].hsl[0]}deg`);

      document.querySelector('[data-colors]').innerHTML = colors.all.reduce((r, c) => {
        return `${r}<i style="--w: ${1 / PARAMS.colors}; --h: ${c.hsl[0]}; --s: ${c.hsl[1] * 100}; --l: ${c.hsl[2] * 100}"></i>`
      }, '');
      
      palette(colors, 'random');
      list(colors);
      //names(colors);
    }

    function points(
      colorsInt, 
      offsetTint, 
      offsetShade, 
      curveAccent, 
      colorsArr, 
      curveMethod, 
      offsetCurveModTint, 
      offsetCurveModShade, 
      minSaturationLight, 
      maxSaturationLight,
    ) {
      $picker.innerHTML = '';
      const limit = Math.PI / 2;
      const part = limit / (colorsInt + 1);

      for (let i = 1; i < (colorsInt + 1); i++) {
        const [x, y] = pointOnCurve(curveMethod, i, colorsInt + 1, curveAccent, minSaturationLight, maxSaturationLight);
        const hsl = hsv2hsl(0, x, y);
        const newElement = document.createElementNS("http://www.w3.org/2000/svg", 'circle');

        newElement.setAttribute('cx', x * 100);
        newElement.setAttribute('cy', 100 - y * 100);

        newElement.setAttribute('r', '3');

        newElement.style.fill = `hsl(${colorsArr[i - 1].hsl[0]}deg,${hsl[1] * 100}%,${hsl[2] * 100}%)`;
        newElement.style.stroke = '#212121';
        newElement.style.strokeWidth = '.5px';

        const [xl, yl] = pointOnCurve(curveMethod, i, colorsInt + 1, curveAccent + offsetCurveModTint, minSaturationLight, maxSaturationLight);

        const newElementLight = document.createElementNS("http://www.w3.org/2000/svg", 'circle');

        newElementLight.setAttribute('cx', (xl - offsetTint) * 100);
        newElementLight.setAttribute('cy', 100 - (yl + offsetTint) * 100);

        newElementLight.setAttribute('r', '1');

        newElementLight.style.fill = `#fff`;
        newElementLight.style.strokeWidth = '0px';

        const newElementDark = document.createElementNS("http://www.w3.org/2000/svg", 'circle');

        const [xd, yd] = pointOnCurve(curveMethod, i, colorsInt + 1, curveAccent - offsetCurveModShade, minSaturationLight, maxSaturationLight);

        newElementDark.setAttribute('cx', (xd - offsetShade) * 100);
        newElementDark.setAttribute('cy', 100 - (yd - offsetShade) * 100);

        newElementDark.setAttribute('r', '1');

        newElementDark.style.fill = `#000`;
        newElementDark.style.strokeWidth = '0px';

        $picker.appendChild(newElement);
        $picker.appendChild(newElementLight);
        $picker.appendChild(newElementDark);
      }

    }
    let colorMode = 'hsl';

    function hslToWhateverString (hsl, whatever) {
      if (whatever === 'hsl') {
        return `${Math.floor(hsl[0])}Â° ${Math.floor(hsl[1] * 100)}% ${Math.floor(hsl[2] * 100)}%`;
      } else if (whatever === 'hex') {
        return culori.formatHex({ mode: 'hsl', h: hsl[0], s: hsl[1], l: hsl[2] });
      } else if (whatever === 'rgb') {
        const col = culori.rgb(`hsl(${hsl[0]},${hsl[1] * 100}%,${hsl[2] * 100}%)`);
        return `${Math.round(col.r * 255)} ${Math.round(col.g * 255)} ${Math.round(col.b * 255)}`;
      }
    }

    function list(colors) {
      const printColors = (arr) => arr.map(({ hsl, rgb, hex, contrast }) => {
        return `
          <li style="--col:${hex}">
            <div class="color-info">
              <div data-copy title="Click to copy">hsl(${Math.floor(hsl[0])},${Math.floor(hsl[1] * 100)}%,${Math.floor(hsl[2] * 100)}%)</div>
              <div data-copy title="Click to copy">rgb(${Math.floor(rgb[0])},${Math.floor(rgb[1] * 100)},${Math.floor(rgb[2] * 100)})</div>
              <div data-copy title="Click to copy">${hex}</div>
              <h5>wcag contrast:</h5>
              <div class="contrast">
                <div><span style="color: #ffffff; text-shadow: 0 0 2px #000000;">â¬¤</span> ${contrast.white.toFixed(2)}</div>
                <div><span style="color: #000000;">â¬¤</span> ${contrast.black.toFixed(2)}</div>
              </div>
            </div>
          </li>
        `
      }).join('');

      document.querySelector('[data-list]').innerHTML = `
        <div>
          <h3>Light Colors</h3>
          <ol>${printColors(colors.light)}</ol>
        </div>
        <div>
          <h3>Base Colors</h3>
          <ol>${printColors(colors.base)}</ol>
        </div>
        <div>
          <h3>Dark Colors</h3>
          <ol>${printColors(colors.dark)}</ol>
        </div>
      `

      if (navigator.clipboard) {
        [...document.querySelectorAll('[data-list] [data-copy]')].forEach($el => {
          const text = $el.innerText;
          $el.addEventListener('click', () => {
            navigator.clipboard.writeText(text).then(() => {
              $el.innerText = 'copied!';
              setTimeout(() => {
                $el.innerText = text;
              }, 500)
            })
          });
        });
      }
    }
    /*
    function names(colors) {
      fetch(`https://api.color.pizza/v1/?values=
      ${colors.}&goodnamesonly=true&noduplicates=true}`)
    }*/

    let timer;
    $pal.addEventListener('pointerdown', () => { palette(colors, 'random'); timer = setInterval(() => palette(colors, 'random'), 100)});
    $pal.addEventListener('pointerup', () => clearInterval(timer));

    $palxl.addEventListener('pointerdown', () => { palette(colors, 'random'); timer = setInterval(() => palette(colors, 'random'), 100) });
    $palxl.addEventListener('pointerup', () => clearInterval(timer));

    pane.on('change', bam);

    bam();
  </script>
</body>

</html>